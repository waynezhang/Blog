---
layout: post
title: 廖雪峰python学习小记
date: 2016-04-13
author:     "Norris"
categories: blog
tags: [python]
---

# 字符编码介绍

ASCII Unicode UTF-8 GBK2312

就问你烦不烦？

来看看[这里吧](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819196283586a37629844456ca7e5a7faa9b94ee8000)

# 格式化字符

在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：

```
>>> 'Hello, %s' % 'world'
'Hello, world'
>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)
'Hi, Michael, you have $1000000.'

```

你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。

常见的占位符有：

%d	整数
%f	浮点数
%s	字符串
%x	十六进制整数
其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：

```
>>> '%2d-%02d' % (3, 1)
' 3-01'
>>> '%.2f' % 3.1415926
'3.14'
```

如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：

```
>>> 'Age: %s. Gender: %s' % (25, True)
'Age: 25. Gender: True'
```

对于Unicode字符串，用法完全一样，但最好确保替换的字符串也是Unicode字符串：

```
>>> u'Hi, %s' % u'Michael'
u'Hi, Michael'
```

有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：

```
>>> 'growth rate: %d %%' % 7
'growth rate: 7 %'
```

# 元组

一个数的元组怎么设置？

要定义一个只有1个元素的tuple，如果你这么定义：

```
>>> t = (1)
>>> t
1
```

定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。

所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：

```
>>> t = (1,)
>>> t
(1,)
```

Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。

# dict & list

和list比较，dict有以下几个特点：

查找和插入的速度极快，不会随着key的增加而增加；
需要占用大量的内存，内存浪费多。
而list相反：

查找和插入的时间随着元素的增加而增加；
占用空间小，浪费内存很少。
所以，dict是用空间来换取时间的一种方法。

dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。

这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。

要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。

# 不可变对象

字符串、整数、元组都是不可变对象，而list是可变对象。

# 函数参数

函数默认参数的设置必须指向不可变参数。

*与**可以用来调用解析参数。分别以元组和字典的形式传入和调用。

# 递归函数

写个阶乘

```
def fact(n):
	if n==1:
		return 1
	return n*fact(n-1)
```

函数递归会导致栈溢出的错误。大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。

# 生成器

[Click Here](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138681965108490cb4c13182e472f8d87830f13be6e88000)

列表推导式用括号代替中括号，变成生成器，或者在函数中使用yield。

# sorted排序算法

sorted([list],fn)

以fn规则进行排序，按照cmp规则来设置fn方程。

# 装饰器

globals()可以以字典形式输出当前环境下的所有全局变量

locals()可以以字典形式输出当前环境下的所有局部变量

```
a='this is a global variable.'
def foo():
    a='this is a local variable'
    print locals()
```


# 偏函数

functools库的partial函数可以自定义默认参数

例如int()函数可以将字符型函数转化成整数型，默认是10进制的转化，但是可以利用参数base=2改变成2进制的转化。如果我们大部分需求都是将数据转化成二进制，那么每次都要在int中输入参数base=2很麻烦，这时候就需要functools.partial函数了。

```
import functools
int2=functools.partial(int,base=2)
int2('100')
int('100')
```

>当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。
时更简单。

# 函数库
每一个.py结尾的文件都可以看做是一个module，如果库名发生了重复，可以建立一个顶层库来分割这些库，但是每一个文件夹下面必须建立一个__int__.py的文件，否则python只会认为这是一个普通的文件夹，而__int__.py本身也就是一个库，就是其上层库。

详情可参考[详细说明](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868200171577d6385bb5b4f4875bee9cbf0f0fa29c5000)

# OOP 面向对象



